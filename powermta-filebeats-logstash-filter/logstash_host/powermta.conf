# sudo /usr/share/logstash/bin/logstash-plugin install logstash-output-exec
# sudo /usr/share/logstash/bin/logstash-plugin install logstash-output-jdbc


input {
  beats {
    port => 5044
    ssl_enabled => true
    ssl_certificate => "/etc/logstash/certs/elk-logstash01.crt"
    ssl_key => "/etc/logstash/certs/elk-logstash01.pkcs8.key"
    ssl_certificate_authorities => "/etc/logstash/certs/ca.crt"
    #ssl.verification_mode: "none"    #putem dezactiva verificarea certificatului, in cazul in care nu a fost emis pentru unul din ip-urile de pe logstash
  }
}

filter {

    csv {
      separator => ","
      columns => ["type","timeLogged","timeQueued","totalSecondsQueued","orig","rcpt","header_tracking-id","header_serverId","header_X-fwd-file","header_X-Local-file","vmta","jobId","envId","dsnAction","dsnStatus","dsnDiag","dsnMta","bounceCat","dlvSourceIp","dlvDestinationIp","dlvType","header_from","header_subject", "queue"]
      skip_header => true
    }

    date {
      match => ["timeLogged", "yyyy-MM-dd HH:mm:ssZ"]
      target => "@timestamp"
    }

    date {
      match => ["timeLogged", "yyyy-MM-dd HH:mm:ssZ"]
      target => "timeLogged"
    }

    date {
      match => ["timeQueued", "yyyy-MM-dd HH:mm:ssZ"]
      target => "timeQueued"
    }

    grok {
      match => { 
	"header_from" => [ 
		"(?<header_from_name>.*)\s*\<(?<header_from_email>.*)\>",
		"(?<header_from_email>[^\<\>\s]+)"
		]
	}
    }

    if [header_from] {
      ruby {
        code => '
          require "mail"
          encoded_string = event.get("header_from")
          decoded_string = Mail::Encodings.value_decode(encoded_string)
          cleaned_string = decoded_string.gsub(/\\|"/, "").strip  # Elimină caracterele \"
          event.set("header_from", cleaned_string)
        '
      }
    }

    if [header_subject] {
      ruby {
        code => '
          require "mail"
          encoded_string = event.get("header_subject")
          decoded_string = Mail::Encodings.value_decode(encoded_string)
          cleaned_string = decoded_string.gsub(/\\|"/, "").strip  # Elimină caracterele \"
          event.set("header_subject", cleaned_string)
        '
      }
    }

    if [header_from_name] {
      dissect {
        mapping => { "header_from_email" => "%{from}@%{domain}" }
      }

      ruby {
        code => '
          require "mail"
          encoded_string = event.get("header_from_name")
          decoded_string = Mail::Encodings.value_decode(encoded_string)
          cleaned_string = decoded_string.gsub(/\\|"/, "").strip  # Elimină caracterele \"
          event.set("header_from_name", cleaned_string)
        '
      }
    }

    if [dsnDiag] =~ /smtp;421 (4\.7\.0 )?\[(TSS04|TSS05|TSS11|IPTS04|IPTS05)\] .* - .*; see .*$/ {
      mutate {
        add_tag => ["SMTP_ERROR"]
      }
    }

    if [dsnDiag] =~ /smtp;554 Message not allowed - \[PH01\] Email not accepted for policy reasons. Please visit https:\/\/senders\.yahooinc\.com\/error-codes$/ {
      mutate {
        add_tag => ["SMTP_ERROR"]
      }
    }

    mutate {
      lowercase => ["rcpt"]
      convert => {
        "dlvSize" => "integer"
        "jobId" => "integer"
        "totalSecondsQueued" => "integer"
      }
      rename => { "header_tracking-id" => "tracking-id" }
      gsub => [ "orig", "^$", "empty" ] # Adaugă valoarea implicită "empty" dacă orig este gol
      gsub => [ "jobId", "null", 9999 ] # Adaugă valoarea implicită
      remove_field => ["message", "path", "@version", "host", "event", "log", "input", "agent", "ecs"]
      remove_tag => ["sender", "beats_input_codec_plain_applied"]
    }

    ruby {
      code => '
        if !event.get("[jobId]").is_a?(Integer)
          event.set("[jobId]", 9999)
        end
      '
    }

ruby {
  init => '
    require "redis"
    def connect_to_redis
      Redis.new(host: "localhost", port: 6379)
    end

    def subscriber_status(rcpt, redis_conn, cache)
      return cache[rcpt] if cache.key?(rcpt)

      is_subscriber = redis_conn.sismember("subscriber_data", rcpt) ? "true" : "false"
      cache[rcpt] = is_subscriber
      is_subscriber
    end

    $redis = connect_to_redis
    $cache = {}
  '
  code => '
    begin
      # Reconnect to Redis if $redis_conn is nil or connection is lost
         if $redis.nil? || !$redis.connected?
            # Dacă conexiunea nu există sau nu este conectată, încercăm să ne reconectăm
            $redis = connect_to_redis
            logger.info("Redis reconnected successfully.")
          end

      rcpt = event.get("rcpt")
      event.set("isSubscriber", subscriber_status(rcpt, $redis, $cache))
    rescue => e
      event.set("redis_error", "true")
      $logger.error("Error in Redis processing: #{e.message}")
    end
  '
}


    metrics {
      meter => "lines"
      add_tag => "metric"
      flush_interval => 60
    }

    if ![totalSecondsQueued] {
      mutate {
        add_field => { "totalSecondsQueued" => 0 }
      }
    }

    mutate {
      convert => { "isSubscriber" => "boolean" } # Convertim valoarea în boolean
    }

}


output {

  #  stdout {
  #    codec => rubydebug
  #  }

    if "SMTP_ERROR" in [tags] {

    stdout { codec => rubydebug }  # Output pentru debugging
    file {
      path => "/var/log/logstash/debugfile_exec.log"
      codec => rubydebug
    }
      exec {
        command => "/etc/logstash/alert.py --timeLogged '%{timeLogged}' --vmta %{vmta} --dsnDiag '%{dsnDiag}'"
      }
    }


   if "metric" not in [tags] {
      jdbc {
         enable_event_as_json_keyword => true
         driver_jar_path => "/usr/share/logstash/logstash-core/lib/jars/mariadb-connector-java.jar"
         connection_string => "jdbc:mariadb://MARIADB_HOST:3306/DATABASE_NAME?user=MARIADB_USER&password=MARIADB_PASSWORD"
         statement => [ "INSERT INTO que2 (queDataType, totalSecondsQueued, isSubscriber, jobId, queDataBody, queLogDate) VALUES ('pmta', ?, ?, ?, ?, NOW())", "totalSecondsQueued", "isSubscriber", "jobId", "@event" ]
      }

      elasticsearch {
         hosts => [ "https://ELASTICSEARCH_HOST_1:9200", "https://ELASTICSEARCH_HOST_2:9200", "https://ELASTICSEARCH_HOST_3:9200" ]
         # ssl => yes
         #cacert => '/etc/logstash/certs/http_ca.crt'
         ssl_certificate_authorities => "/etc/logstash/certs/ca.crt"
         password => 'ELASTICSEARCH_PASSWORD'
         user => 'ELASTICSEARCH_USER'
         index => "pmta-%{+YYYY.MM.dd}"
      }
    }

    if "metric" in [tags] {
      stdout {
        codec => line {
          format => "PMTA Rate: %{[lines][rate_1m]} / minute, %{[lines][rate_5m]} / 5 minute"
        }
      }
    }
}
